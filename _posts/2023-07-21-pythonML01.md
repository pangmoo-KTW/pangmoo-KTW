---
layout: post
title: "NumPy 개요"
author: 김태원
categories: MachineLearning
tags: [MachineLearning]
---

> *José Unpingco의 [Python for Probability, Statistics, and Machine Learning](https://library.samdu.uz/files/7cbb6fdd660fb2c0f0580bfd6ed73040_Python%20for%20Probability,%20Statistics,%20and%20Machine%20Learning.pdf){:target="_blank"}을 읽으며 기록한 내용입니다.*
>

여기 파이썬을 사용하는 프로그래머가 있다.
프로그래머는 배열로 뭘 하고 싶다.
그런데 파이썬에 내장된 배열 기능은 마음에 들지 않는다.
그러므로 도서관(library)에서 가져올 생각이다. 
도서관은 영어식으로 라이브러리라고 부르겠다. 

우선 라이브러리에서 뭘 가져오려면 기억 공간을 따로 내어줘야 한다.
전문적으로는 "파이썬 인터프리터에 메모리를 배정한다"고 말한다.
라이브러리는 배정된 메모리에 입력(input)으로 들어온다.
라이브러리는 열심히 배열 기능을 수행하겠다. 
물론 라이브러리가 결과물을 출력(output)하더라도 끝난 게 아니다.
파이썬 인터프리터에게 출력을 반환(return)해야 한다. 

쌍방향 메모리 교환인 셈이다. 
이를 깔끔하게 처리하는 것이 NumPy다. 
NumPy는 'Numerical Python'을 축약한 표현으로, 수치 계산을 위한 파이썬이라는 뜻이다. 
배열과 같은 수치계산상의 기능에 대한 쌍방향 메모리 교환을 잘 하는 것으로 유명한 모듈이다.

우선 NumPy를 가져와야 한다. 가져오는 걸 영어로 `import`라고 한다. 
```python
>>> import numpy as np
```
`numpy`를 가져오는데 `np`로 명명한다는 뜻이다. 
굳이 또 줄여서 가져오는 이유는 NumPy를 사용할 때마다 `numpy.어쩌구리`라고 하는 것보다 `np.어쩌구리`라고 하는 쪽이 편하기 때문이다. 

이제 `np`라는 이름의 공간에서 배열을 가져와 `[1,2,3]`이라는 목록을 입력하겠다. 그리고 그 결과를  `x`에 배정하겠다.
```python
>>> x = np.array([1,2,3])
```
`x`는 예상할 수 있겠지만 아래와 같다.
```python
>>> x
array([1,2,3])
```
`np.array`로는 물론 정수만이 아니라 특정 크기의 실수를 요소로 지니는 배열을 배정할 수 있다. 
32비트, 다시 말해 4바이트 부동소수점수 `float32`를 요소로 지니게끔 `x`를 다시 정의하면 아래와 같다.
```python
>>> x = np.array([1,2,3],dtype=np.float32)
>>> x
array([1.,2.,3., dtype=float32)
>>> x.itemsize # x라는 배열 속 각 요소의 크기
4
```
NumPy는 이처럼 단일 형식을 지니는(uniform) 컨테이너를 제공한다. 
또 NumPy는 **보편 함수**(universal functions)라는 것도 제공한다. 
약식으로 `ufuncs`라고 부르는 것이다. 
`ufuncs`는 어떤 의미에서 **보편적**일까?
바로 한 (계산 가능한) 함수가 다른 (계산 가능한) 함수를 계산할 수 있다는 뜻이다.
이를테면 `np.array`라는 함수를 NumPy의 사인 함수인 `np.sin`에 통째로 입력할 수 있다. 
```python
>>> np.sin(np.array([1,2,3],dtype=np.float32))
array([0.841471 , 0.9092974, 0.14112  ], dtype=float32)
```
파이썬에 내장된 `math` 모듈로 사인 함수를 실행할 수도 있다.
하지만 NumPy가 훨씬 빠르다. 
프로그래머가 명시적으로 `for` 루프를 수행할 필요가 없기 때문이다. 
즉 `math` 모듈만으로 사인 함수를 수행하려면 프로그래머가 배열상의 원소들을 돌면서 하나씩 사인 함수를 수행해야 한다.
```python
>>> from math import sin
>>> [sin(i) for i in [1,2,3]]
[0.8414709848078965, 0.9092974268256817, 0.1411200080598672]
```
반면 `np.sin`의 경우 루프는 이미 컴파일된 `np.sin` 함수 자체에서 일어난다. 
그래서 더 빠르다.
`ufuncs`의 힘이다.
그래도 `np.array`가 파이썬의 슬라이싱(slicing) 규칙을 따르지 않는 것은 아니다.
아래 같은 $2\times3$ 배열이 있다고 하자.
```python
>>> x = np.array([[1,2,3],[4,5,6]])
>>> x
array([[1, 2, 3],
       [4, 5, 6]])
```
여기서 $n$번째 열에 있는 모든 원소만 가져올 수도 있고
```python
>>> x[:,0]
array([1,4])
```
$n$번째 행에 있는 모든 원소만 가져올 수도 있다. 
```python
>>> x[0,:]
array([1,2,3])
```
$n$번째 열 이후의 모든 행원소를 가져올 수도 있다.
```python
>>> x[:,1:]
array([[2, 3],
       [5, 6]])
```
전체 행에 대해 $0$번 열, $2$번 열과 같은 방식으로 $2$ 스텝으로 참조하여 배열을 만들 수도 있다. 
```python
>>> x[:,::2]
array([[1, 3],
       [4, 6]])
```
음수 스텝을 부여하여 뒤집을 수도 있다.
```python
>>> x[:,::-2]
array([[3, 1],
       [6, 4]])
```
여기서 원본 `x` 배열을 계속 재사용한 것으로 알 수 있듯이 NumPy의 슬라이싱은 일종의 시야만 제공한다. 
시야는 영어로 뷰(view)라고 부르는 쪽이 편하겠다. 
아무튼 `x[:,::-2]`의 사본(copy)이 만들어지는 것은 아니다. 
사본을 만들 수도 있다. 
인덱싱(indexing)을 사용한다.
`x`가 $3\times 3$ 배열이라고 하자.
```python
>>> x = np.array([[1,2,3],[4,5,6],[7,8,9]])
>>> x
array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])
```
`x`의 모든 행에 대해 마지막 $2$번째 열만 하나 더 추가한다. 
```python
>>> x[:,[0,1,2,2]]
array([[1, 2, 3, 3],
       [4, 5, 6, 6],
       [7, 8, 9, 9]])
```
그리고 이번에는 위 행렬을 `y`에 배정한다.
```python
>>> y = x[:,[0,1,2,2]]
>>> y
array([[1, 2, 3, 3],
       [4, 5, 6, 6],
       [7, 8, 9, 9]])
```
여기서 변수 `y`는 제 메모리를 지닌다. 
`x`에 대해 인덱싱을 수행한 결과가 복사되었기 때문이다.
핵심은 그 결과만 복사했을 뿐이라는 사실이다. 
따라서 이후 `x`를 건드려도 `y`에 영향을 미치지 않는다.
```python
>>> x[0,0] = 999
>>> x
array([[999,   2,   3],
       [  4,   5,   6],
       [  7,   8,   9]])
>>> y
array([[1, 2, 3, 3],
       [4, 5, 6, 6],
       [7, 8, 9, 9]])
```
반면 슬라이싱으로 `y`를 정의하면 `x`상의 변화가 그대로 `y`에도 적용된다.
앞서 언급했듯이 이 경우 `y`는 `x`에 대한 뷰일 따름이다. 
```python
>>> x = np.ones((3,3))
>>> x
array([[1., 1., 1.],
       [1., 1., 1.],
       [1., 1., 1.]])
>>> y = x[:2,:2]
>>> y
array([[1., 1.],
       [1., 1.]])
>>> x[0,0] = 999
>>> x
array([[999.,   1.,   1.],
       [  1.,   1.,   1.],
       [  1.,   1.,   1.]])
>>> y
array([[999.,   1.],
       [  1.,   1.]])
```
그런데 영향을 미치지 않기를 바랄 수도 있다.
즉 뷰가 필요한 경우가 있다. 
신호 및 영상 처리 알고리즘이 대표적이다. 
이들 알고리즘은 메모리가 겹칠 것(overlapping)을 요구한다.
가령 아래 예는 추가적인 메모리 소비 없이 겹치는 블록을 보인다.
```python
>>> x = np.arange(16, dtype=np.int64)
>>> x
array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15])
>>> y = as_strided(x,(7,4),(16,8))
>>> y
array([[ 0,  1,  2,  3],
       [ 2,  3,  4,  5],
       [ 4,  5,  6,  7],
       [ 6,  7,  8,  9],
       [ 8,  9, 10, 11],
       [10, 11, 12, 13],
       [12, 13, 14, 15]])
```
위 예시는 정수의 범위(range)를 `x`에 배정한 다음 그 요소를 겹쳐서 $7\times4$ NumPy 배열을 만든다. 
`as_strided`의 두 번째 인자 `(16,8)`은 행원소들이 열이동할 적의 보폭 16바이트와 열원소들이 행이동할 적의 보폭 8바이트를 나타낸다. 
요점은 메모리 재사용이다. 
`x`의 $2n$번째 원소에 대해 다른 값을 대입하면 `y`도 변한다.
```python
>>> x[::2] = 99
>>> x
array([99,  1, 99,  3, 99,  5, 99,  7, 99,  9, 99, 11, 99, 13, 99, 15])
>>> y
array([[99,  1, 99,  3],
       [99,  3, 99,  5],
       [99,  5, 99,  7],
       [99,  7, 99,  9],
       [99,  9, 99, 11],
       [99, 11, 99, 13],
       [99, 13, 99, 15]])
```
실은 지금까지 배열(array)과 행렬(matrix)의 용어를 사뭇 오도적으로 혼용했는데, 둘은 다른 개념이다.
행렬에는 행렬 연산이 결부된다. 
```python
>>> A = np.matrix([[1,2,3],[4,5,6],[7,8,9]])
>>> x = np.matrix([[1],[0],[0]])
>>> A * x
matrix([[1],
        [4],
        [7]])
```
반면 `np.array`는 행렬곱이 아니라 원소별 곱이 기본이다. 
`np.array`로 행렬곱을 수행하려면 `.dot()`을 사용해야 한다. 
아무튼 더 강력한 기능이 남아있다.
바로 격자를 생성하는 기능이다. 
```python
>>> x = np.array([0,1])
>>> y = np.array([0,1])
>>> x
array([0, 1])
>>> y
array([0, 1])
>>> x + y
array([0, 2])
>>> x + y[:,None]
array([[0, 1],
       [1, 2]])
```
`x + y[:,None]`은 아래 같은 계산이다.

$$
\begin{aligned}
&x = [0,1] \longrightarrow \begin{bmatrix}0 & 1 \\ 0 & 1\end{bmatrix},\quad 
y = [0,1] \longrightarrow \begin{bmatrix}0 & 0 \\ 1 & 1\end{bmatrix} \\ 
&\longrightarrow
\begin{bmatrix}
0 & 1\\0 & 1
\end{bmatrix} +
\begin{bmatrix}
0 & 0 \\ 1 & 1
\end{bmatrix}
= \begin{bmatrix}
0 & 1 \\ 1 & 2
\end{bmatrix}
\end{aligned}
$$
